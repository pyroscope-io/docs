---
id: server-api-reference
title: API Reference
sidebar_label: API Reference
slug: /server-api-reference
description: Pyroscope HTTP API Reference
keywords: [ pyroscope, api, http, integration ]
---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## HTTP API

### Authentication

When Pyroscope Server [authentication providers](auth-overview.mdx) are configured,
API clients should provide a **Bearer** authentication token in the **Authorization** header, like this:

```
GET http://your.pyroscope.com/render HTTP/1.1
Accept: application/json
Authorization: Bearer psx-BWlqy_dW1Wxg6oBjuCWD28HxGCkB1Jfzt-jjtqHzrkzI
```

cURL example:
```shell
curl --fail \
  -H "Authorization: Bearer psx-BWlqy_dW1Wxg6oBjuCWD28HxGCkB1Jfzt-jjtqHzrkzI" \
  http://localhost:4040/render\?from\=now-1h\&until\=now\&query\=pyroscope.server.cpu%7B%7D\&max-nodes\=1024\&format\=json
```

Please refer to the [API Key Authentication](api-key-authentication.mdx) paragraph to learn how to create
an API key.

:::note
`/ingest` endpoint authentication is configured separately via the `auth.ingest.enabled` parameter. Please see the
[agent authentication](api-key-authentication.mdx/#authenticate-agents-with-an-api-key) paragraph for details.
:::

### Ingestion

Currently there's just one endpoint: `POST /ingest`. It takes profile data in request body and metadata as query params.

It takes multiple query parameters:

| Name               | Description                             | Notes                           |
|:-------------------|:----------------------------------------|:--------------------------------|
| `name`             | application name                        | required, should be url-encoded |
| `from`             | UNIX time of when the profiling started | required                        |
| `until`            | UNIX time of when the profiling stopped | required                        |
| `format`           | format of the profiling data            | optional (default is `folded`)  |
| `sampleRate`       | sample rate used in Hz                  | optional (default is 100 Hz)    |
| `spyName`          | name of the spy used                    | optional                        |
| `units`            | name of the profiling data unit         | optional (default is `samples`  |
| `aggregrationType` | type of aggregration to merge profiles  | optional (default is `sum`)     |

* `name` specifies application name. It may be specified in the fully qualified application name notation as described in [the specification](/docs/flameql#notation). For example:
```
my.awesome.app.cpu{env=staging,region=us-west-1}
```

Request body contains the profiling data, and request header `Content-Type` may also be alongside `format` to determine profiling data format.

Some of the query parameters depend on the format of profiling data. Pyroscope currently supports three major ingestion formats.

#### Formats with a single profile type.

Most simple ingestion formats send a single type of profiling data and don't usually support any metadata within the format to indicate which kind of data they are sending.
In these cases, all the metadata is taken from the query parameters, and the format itself is defined by a combination of both `from` query parameter and `Content-Type` body header.
The formats that work this way are:

* `folded`. This is the default format. With this format you put one stacktrace per line with a number of samples you've captured for that particular stacktrace, for example:
```
foo;bar 100
foo;baz 200
```
* `trie`. A `Content-Type` set to `binary/octet-stream+trie` and a `format` set to `trie` indicates that profile data is sent in this format.
  This format uses a stacktrace trie and variable-length integers to serialize data in a highly space-optimized way. It's not recommended for third-party integrations.
* `tree` A `Content-Type` set to `binary/octet-stream+tree` and a `format` set to `tree` indicates that profile data is sent in this format.
  This format uses a stacktrace tree and variable-length integers to serialize data in an efficient way that matches Pyroscope's internal tree representation. It's not recommended for third-party integrations.
* `lines` A `format` set to `lines` indicates that profile data is sent in this format. This format is similar to `folded`, except there's no number of samples per stacktrace but a single line per sample, for example:
```
foo;bar
foo;bar
foo;baz
foo;bar
```
  
#### pprof format

TBD

#### JFR format

This is the [Java Flight Recorder](https://openjdk.java.net/jeps/328) format, typically used by JVM-based profilers, also supported by [our Java integration](https://github.com/pyroscope-io/pyroscope-java#jfr-format-and-multiple-event-support).

When this format is used, some of the query parameters behave slightly different:
* `format` should be set to `jfr`.
* `name` contains the _prefix_ of the application name. Since a single request may contain multiple profile types, the final application name is created concatenating this prefix and the profile type.
* `units` is ignored, and the actual units depends on the profile types available in the data.
* `aggregationType` is ignored, and the actual aggregation type depends on the profile types available in the data.

JFR ingestion support uses the profile metadata to determine which profile types are included, which depend on the kind of profiling being done. Currently supported profile types include:
* `cpu` samples, which includes only profiling data from runnable threads.
* `itimer` samples, similar to `cpu` profiling.
* `wall` samples, which includes samples from any threads independently of their state. 
* `alloc_in_new_tlab_objects`, which indicates the number of new TLAB objects created.
* `alloc_in_new_tlab_bytes`, which indicates the size in bytes of new TLAB objects created.
* `alloc_outside_tlab_objects`, which indicates the number of new allocated objects outside any TLAB.
* `alloc_in_new_tlab_bytes`, which indicates the size in bytes of new allocated objects outside any TLAB.

#### Examples

Here's a sample code that uploads a very simple profile to pyroscope:
<Tabs
  defaultValue="curl"
  values={[
    {label: 'cURL', value: 'curl'},
    {label: 'Python', value: 'python'},
  ]}>
  <TabItem value="curl">

```shell
printf "foo;bar 100\n foo;baz 200" | curl \
-X POST \
--data-binary @- \
'http://localhost:4040/ingest?name=curl-test-app&from=1615709120&until=1615709130'
```

  </TabItem>
  <TabItem value="python">

```python
import requests
import urllib.parse
from datetime import datetime

now = round(datetime.now().timestamp()) / 10 * 10
params = {'from': f'{now - 10}', 'name': 'python.example{foo=bar}'}

url = f'http://localhost:4040/ingest?{urllib.parse.urlencode(params)}'
data = "foo;bar 100\n" \
"foo;baz 200"

requests.post(url, data = data)
```

  </TabItem>
</Tabs>

### Adhoc support

In [adhoc profiling mode](https://pyroscope.io/blog/pyroscope-adhoc-profiling/) the way Pyroscope works with integrations that use
the HTTP API is as follows:
- Pyroscope starts listening to profiles in an available port.
- Pyroscope sets the environment variable `PYROSCOPE_ADHOC_SERVER_ADDRESS` with the address where its listening.
- Pyroscope launches the profiled application.
- the profiled application sends the profiling data through the HTTP API.

For this to work as expected, the new integrations should check if this environment variable exists and in that case,
they should override the server address with this value. This is enough to make adhoc profiling work seamlessly with the new integration.

How adhoc profiling mode was added to the [java integration](https://github.com/pyroscope-io/pyroscope-java/pull/5) can be used as an example.
