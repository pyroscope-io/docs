---
id: ci
title: Running Pyroscope in CI
sidebar_label: Running in CI
slug: /ci
keywords: [ ci ]
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Link from '@docusaurus/Link';

# Running Pyroscope in a CI/CD pipeline

If you're running tests in a CI/CD pipeline, you can use Pyroscope to profile your tests and upload the results to Pyroscope Cloud.
This allows you to identify performance bottlenecks and optimize your code.

To use Pyroscope in a CI/CD pipeline, you'll need to install the pyroscope-ci binary. This binary provides the functionality for
profiling tests and uploading the results.


## Installation
The `pyroscope-ci` binary can be downloaded from the [Github Releases page](https://github.com/pyroscope-io/ci/releases).
A convenient installation script is available to automate this process:
```bash
curl https://raw.githubusercontent.com/pyroscope-io/ci/main/install.sh | sh
```
You can also download the script and inspect its contents before running it. We recommend pinning the installation to a fixed commit.

After running the installation script, you'll have access to the pyroscope-ci binary in your project. You can run it using:
```
./pyroscope-ci [COMMAND]
```

If you're using Github Actions, we recommend using [`jaxxstorm/action-install-gh-release`](https://github.com/jaxxstorm/action-install-gh-release) action to install the `pyroscope-ci` binary.
For a more complete example see the [Integrating with Github Actions](#integrating-with-github-actions) section below.

## CI profiling steps
To use Pyroscope in your CI/CD pipeline, you'll need to perform three steps: setup, execution, and upload.

1. **Setup:** In this step, you'll initialize Pyroscope and start profiling. This is typically done in a setup script that runs before your tests.
2. **Execution:** In this step, you'll run your tests while Pyroscope is profiling them. Pyroscope will record performance data for each test.
3. **Upload:** In this step, you'll upload or export the profiling data. This allows you to view the data and analyze the performance of your code.

The following sections provide language/testing framework specific instructions for each of these steps:

<Tabs
  defaultValue="go"
  values={[
    {label: 'Go', value: 'go'},
    {label: 'Nodejs (jest)', value: 'nodejs-jest'},
  ]}>
  <TabItem value="go">
  ## Profiling Go tests

  To profile your Go tests with Pyroscope, you can use the `./pyroscope-ci go` command.
  This command will recursively search for all Go test packages under the `pkg` directory, generate a `pyroscope_test.go` file for each package,
  and instrument the test functions with the Pyroscope agent.

  Here's an example of how to use pyroscope-ci go to profile your tests:
  ```bash
  # Note you may need to pull the `pyroscope` dependency, if you are not using it yet.
  # go mod tidy
  ./pyroscope-ci go install --applicationName=myapp pkg
  ```

  Note that the --applicationName flag specifies the name of the application being profiled.

  We recommend running as a ci step, so that you don't have to commit these lines and profile tests when running locally.

  That's it! Pyroscope will now profile your tests in your CI/CD pipeline.

  </TabItem>
  <TabItem value="nodejs-jest">

  ## Profiling Node.js tests
  To use Pyroscope with Node.js, you'll need to install the @pyroscope/nodejs agent. You can do this via npm or yarn:

  ```bash
  npm install --save-dev @pyroscope/nodejs
  # or
  yarn add --dev @pyroscope/nodejs
  ```

  ### Setting up Pyroscope in node
  To set up Pyroscope, you'll need to create two new files in your project (or edit them if they already exist):

  1. `globalSetup.js`: This file initializes Pyroscope and starts profiling. 
  Pyroscope will only profile your code when the CI environment variable is turned on. Here's an example:
  ```js
  const Pyroscope = require('@pyroscope/nodejs');

  module.exports = () => {
    Pyroscope.init({
      serverAddress: '_',
      appName: 'myapp.frontend',
    });
    if (process.env.CI) {
      Pyroscope.start();
      // Pyroscope.startCpuProfiling(); // Use this for better performance if heap profiling isn't needed
    }
  };
  ```
  If you don't care about heap profiling, you can replace .start() with .startCpuProfiling() to reduce the performance overhead.

  2. `globalTeardown.js`: This file stops profiling and exports the profiling data. Here's an example:
  ```js
    const Pyroscope = require('@pyroscope/nodejs');
    module.exports = (config) => {
      if (process.env.CI) { // Note: be sure to set this ENV variable
        Pyroscope.stopCpuProfiling();
        Pyroscope.stopHeapProfiling();
      }
    };
  ```
  Notice how we conditionally start Pyroscope when the `CI` environment variable is set to `true` so that by default we
  don't profile tests when running locally.


  ### Configuring Jest
  To tell Jest to use these files for configuration, add the following to your `jest.config.js` file:

  ```js
  module.exports = {
    // ...
    globalSetup: '<rootDir>/globalSetup.js',
    globalTeardown: '<rootDir>/globalTeardown.js',
    // ...
  }
  ```
  That's it! Pyroscope will now profile your tests in your CI/CD pipeline.
  
  </TabItem>
</Tabs>

## Execution
After your tests have been set up, it's time to execute them:


<Tabs
  defaultValue="go"
  values={[
    {label: 'Go', value: 'go'},
    {label: 'Nodejs (jest)', value: 'nodejs-jest'},
  ]}>
  <TabItem value="go">

  ```bash
  pyroscope-ci exec --apiKey="MY_API_KEY" -- go test ./...
  ```

:::note
Some CI systems will skip certain tests if the files have not been touched.
If you don't want that behaviour, try to run your tests without cache. In go you can use `go test . -count=1`
:::

  </TabItem>
  <TabItem value="nodejs-jest">

  `jest` needs to run with the `--runInBand` flag.
  This is so that the profiling session started in `globalSetup.js` is available to all tests.
  Otherwise `jest` [spawns different workers without the ability to perform individual setup/teardown](https://github.com/facebook/jest/issues/8708).

:::note
Some CI systems will skip certain tests if the files have not been touched.
If you don't want that behaviour, try to run your tests without cache, using `--no-cache` flag
:::

  ```bash
  pyroscope-ci exec --apiKey="MY_API_KEY" -- npm run test --runInBand
  ```
  Or if using `yarn` (or `pnpm`)

  ```bash
  pyroscope-ci exec --apiKey="MY_API_KEY" -- yarn run test --runInBand
  ```

  For more info, see the <Link to="https://github.com/pyroscope-io/ci/tree/main/examples/nodejs/jest">example</Link>.
  </TabItem>
</Tabs>

Notice that any command can be set (`make test`, `./test.sh` etc).

### How it works
This command:
1. It starts an in-memory pyroscope server;
2. Overwrites the `PYROSCOPE_ADHOC_SERVER_ADDRESS` environment variable, so that the in-memory server ingests the data. 
(Please check if the agent you are using supports that feature.)
3. Uploads to `--serverAddress` (defaults to `https://pyroscope.cloud`)

### Running locally

When first setting up the integration, you may want to run locally first to validate it's working properly.

```bash
CI=true pyroscope-ci exec --noUpload --export -- $MY_TEST_COMMAND
```

This command will export JSON files to `pyroscope-ci-output`, which can be uploaded to [Flamegraph.com](https://flamegraph.com).

## Upload
:::note
This functionality is only available in [Pyroscope Cloud](https://pyroscope.cloud/ci)
:::

As previously mentioned, the `exec` command also performs upload, but let's dive into it separately,
since it's conceptually a different step.

The CI Context (branch, commit) will be inferred from the environment.
If your the auto detection service doesn't work with your CI system, you can pass each flag manually (`--branch` and `--commitSHA`).

All the data gathered while your tests were running will be merged and grouped by profile type, which is then uploaded.

Alternatively, the `--noUpload` flag can be passed, which creates profiles in the `--outputDir` (defaults to `./pyroscope-ci`).
These profiles can be uploaded to [www.flamegraph.com](https://www.flamegraph.com),
via the [UI](https://www.flamegraph.com), the [API](https://flamegraph.com/openapi) or using the [flamegraph.com Github Action](https://github.com/pyroscope-io/flamegraph.com-github-action).

## Integrating with Github Actions

The following is a simplified example taken from the [`pyroscope` repository](https://github.com/pyroscope-io/pyroscope/blob/main/.github/workflows/ci-profiling.yaml) using Github Actions:

```yaml
name: CI Profiling

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  js-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '16.18'
      - name: Install pyroscope-ci
        uses: jaxxstorm/action-install-gh-release@v1.5.0
        with: # Grab the latest version
          repo: pyroscope-io/ci
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Install Webapp dependencies
        run: yarn install --frozen-lockfile
      - name: Run tests and upload
        run: pyroscope-ci exec --apiKey=${{ secrets.PYROSCOPE_CLOUD_TOKEN }} yarn test --no-cache --max-workers=1
```

## Visualizing profiles
The profiles can be visualized in the [CI page under Pyroscope Cloud](https://pyroscope.cloud/ci).


<iframe frameBorder="0" width="100%" height="400" src="https://flamegraph.com/share/68b22ba6-9d82-11ed-a9bc-e2a53ffd5c62/iframe?colorMode=light&onlyDisplay=flamegraph"></iframe>

For illustration, above is the profile for `github.com/pyroscope-io/pyroscope` go tests,
which shows that the race condition detector (`racecall`) spends a non-negligible amount of time.

