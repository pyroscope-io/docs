---
title: The positives and negatives of profiling with eBPF
sidebar_label: Profiling with eBPF
slug: /positives-negatives-profiling-ebpf
date: "2022-09-05"

authors:
  - name: Ryan Perry
    url: https://github.com/Rperry2174
    image_url: https://avatars.githubusercontent.com/u/23323466?v=4
---

## What is eBPF?

At its root, eBPF takes advantage of the kernelâ€™s privileged ability to oversee and control the entire system.
With eBPF you can run sandboxed programs in a privileged context such as the operating system kernel.
To better understand the implications and learn more check out this [blog post](https://ebpf.io/what-is-ebpf)
which goes into much more detail.

![image](https://user-images.githubusercontent.com/23323466/188525916-0e33c64a-9a7a-4fe2-84d6-91111c4d6f39.png)

As you can see in the diagram, some of the most popular use cases for eBPF are related to Networking, Security,
and most relevenat to this blog post -- observability (logs, metrics, traces, and profiles).

## Landscape of eBPF profiling

Over the past few years there has been significant growth in the profiling space as well as the eBPF space and
there are a few notable companies who are innovating at the intersection of profiling and eBPF. Some examples include:

- Pyroscope
- Parca
- Pixie
- Prodfiler (not open source)

While stars are more of a vanity metric, the collective growth is representative of the rapidly growing interest in this space Pyroscope, Pixie, and Parca all gained a significant amount of stars over the same 6 month period.
![image](https://user-images.githubusercontent.com/23323466/188765863-264f9ff3-9d26-4019-8cb3-a26f8535cc7b.png)


It's also worth noting that all the companies listed above, along with many other open source maintainers, OTel community members, and end-users,
have officially proposed for OpenTelemetry to support profiling alongside logs, metrics, and traces. For more information on that or to join the
efforts check out the `#otel-profiling` channel on the CNCF slack!

## Current state of eBPF profiling

There's a wide spectrum of "challenges" with eBPF profiling that can drastically change the value you're able to get from eBPF profiling.
This is a list roughly sorted from "easier" fairly standard functionality to "harder" more advanced functionality:

- Collecting data with Low-overhead
- Auto-tagging profiles with available metadata
- Finding the best _format_ in which to send profiling data
- Dealing with collecting, storing, and applying Symbols
- Finding ways to deal with _lack_ of symbols
- Finding efficient ways to do other kinds of profiling such as memory profiling
- Finding ways to apply tags dynamically and/or arbitrarily

This blog will focus on Pyroscope's unique approach to solving these issues, particularly the more difficult ones.

## Pros and cons of eBPF profiling vs non-eBPF profiling

When it comes to modern eBPF profiling, it effectively happens at two different levels of the operating system:

- User-space level: Popular non-eBPF profilers like pprof, async-profiler, rbspy, py-spy, pprof-rs, dotnet-trace, etc. operate at this level
- Kernel-level: eBPF profilers operate at this level (examples?)

The reason that there is this chasm between eBPF profilers and non-eBPF profilers is because at each level
of the operating system there are positives and negatives of profiling at that particular level.

<div className="blog-pros-cons">
  <div className="row">
    <div className="col col--12">
      <h3>
        <img src="/img/logos/go_logo_100x100-01.png"/>
        <img src="/img/logos/java_logo_100x100-01.png"/>
        <img src="/img/logos/python_logo_100x100-01.png"/>
        <span>Positives and negatives of<br/>native-language profiling</span>
        <img src="/img/logos/dotnet_logo_100x100-01.png"/>
        <img src="/img/logos/ruby_logo_100x100-01.png"/>
        <img src="/img/logos/rust_logo_100x100-01.png"/>
      </h3>
    </div>
  </div>
  <div className="row">
    <div className="col col--6 pros">
      <h4>Positives</h4>
      <ul>
        <li>Ability tag application code in flexible way (i.e, tagging spans, controllers, functions)</li>
        <li>Ability to profile various specific parts of code (i.e. Lambda functions, Test suites, scripts)</li>
        <li>Ability/simplicity to profile other types of data (i.e. Memory profiling, goroutines)</li>
        <li>Consistency of access to symbols across all languages</li>
        <li>Simplicity of using in local development</li>
      </ul>
    </div>
    <div className="col col--6 cons">
      <h4>Negatives</h4>
      <ul>
        <li>Complexity, for large multi-language systems, to get fleet-wide view</li>
        <li>Constraints on ability to auto-tag infrastructure metadata (i.e. kubernetes)</li>
      </ul>
    </div>
  </div>
</div>


<div className="blog-pros-cons">
  <div className="row">
    <div className="col col--12">
      <h3>
        <img src="/img/logos/ebpf_logo_100x100-01.png"/>
        <span>Positives and negatives of<br/>eBPF profiling</span>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII"/>
      </h3>
    </div>
  </div>
  <div className="row">
    <div className="col col--6 pros">
      <h4>Positives</h4>
      <ul>
        <li>Ability to get fleet-wide, whole-system metrics easily</li>
        <li>Ability to auto-tag metadata that's available at kernel-level (i.e. kubernetes pods, namespaces)</li>
        <li>Simplicity of adding profiling at infrastructure level (i.e. multi-language systems)</li>
        <li>Consistency of access to symbols across all languages</li>
        <li>Simplicity of using in local development</li>
      </ul>
    </div>
    <div className="col col--6 cons">
      <h4>Negatives</h4>
      <ul>
        <li>Requirements call for particular linux kernel versions</li>
        <li>Constraints on being able to tag user-level code</li>
        <li>Constraints on performant ways to retrieve certain profile types (i.e. memory, goroutines)</li>
        <li>Difficulty of developing locally for developers</li>
      </ul>
    </div>
  </div>
</div>


## Pyroscope's solution: Merge User-space and Kernel profiling
<img width="915" alt="image" src="https://user-images.githubusercontent.com/23323466/188767811-a45c0b2c-ec62-4f5e-8fe1-eae3e347e7e0.png"/>

We believe that there's benefits to _both_ eBPF and non-eBPF profiling and our focus long term is to integrate them together seamlessly in Pyroscope.
You may notice above, the "negatives" of one are the "positives" of the other and the maximum value comes from the fact that using both cancels out
the "negatives" while still benefiting from the "positives". 

Long term, we've charted out several promising paths to continue improving our integrations and bridge the gap between eBPF and user-space profiling.
One of the most promising approaches is: (example)

However, in the meantime, we recommend using:
- Non-eBPF language-specific integrations for more granular control and analytic capabilities (i.e. dynamic tags and labels)
- eBPF integration for a comprehensive view of the whole cluster

In fact, this is actually how we profile our cloud product's code internally:
- eBPF for our kubernetes cluster
- ruby gem, pip package, go client, and java client _with tags_ for our language microservices and testing suites
- Lambda extension for our lambda functions

We use eBPF to profile our rideshare example cluster running on kubernetes for our
Go, Python, Ruby, Java, and Rust examples. Looking at the resulting flamegraph gives a good insight into the
type of information and specificity you get for the user-space profiling results vs. the eBPF results.

## Examples
### eBPF Java profiling
### user-space Java profiling (pyroscope-java forked from async-profiler)

### eBPF ruby profiling
### user-space Ruby profiling (pyroscope ruby gem forked from rbspy)

import '@pyroscope/flamegraph/dist/index.css';
import {Flamegraph} from '../src/components/Blog/Flamegraph';
import {GolangEbpf} from '../src/components/Blog/GolangEbpf';
import {GolangNative} from '../src/components/Blog/GolangNative';
import {RubyEbpf} from '../src/components/Blog/RubyEbpf';
import {RubyNative} from '../src/components/Blog/RubyNative';
import {PythonEbpf} from '../src/components/Blog/PythonEbpf';
import {PythonNative} from '../src/components/Blog/PythonNative';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
console.log('simple tree', GolangEbpf);

<Tabs
  defaultValue="ebpfGolang"
  values={[
    {label: 'eBPF Golang', value: 'ebpfGolang'},
    {label: 'Native Golang', value: 'nativeGolang'},
    {label: 'eBPF Ruby', value: 'ebpfRuby'},
    {label: 'Native Ruby', value: 'nativeRuby'},
    {label: 'eBPF Python', value: 'ebpfPython'},
    {label: 'Native Python', value: 'nativePython'},
  ]}>

  <TabItem value="ebpfGolang">
    <Flamegraph profileData={GolangEbpf}></Flamegraph>
  </TabItem>
  <TabItem value="nativeGolang">
    <Flamegraph profileData={GolangNative}></Flamegraph>
  </TabItem>
  <TabItem value="ebpfRuby">
    <Flamegraph profileData={RubyEbpf}></Flamegraph>
  </TabItem>
  <TabItem value="nativeRuby">
    <Flamegraph profileData={RubyNative}></Flamegraph>
  </TabItem>
    <TabItem value="ebpfPython">
    <Flamegraph profileData={PythonEbpf}></Flamegraph>
  </TabItem>
  <TabItem value="nativePython">
    <Flamegraph profileData={PythonNative}></Flamegraph>
  </TabItem>
</Tabs>
